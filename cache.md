##### redis：基于IO多路复用的单线程事件驱动模型，6.0之后网络io由单独的多个线程处理，整体仍然保持单线程模型
0. 主线程模型：循环执行
 ```
1. 获取最近的时间事件，计算剩余时间remained_ms
2. 阻塞等待文件事件(阻塞时长为remained_ms)
3. 处理所有到达的文件事件
4. 处理所有到达的时间事件
5. goto 1
这个模型避免了一直轮询文件事件，又避免了一致阻塞在文件事件。
同时，主线程会尽可能避免饥饿发生，所以如果一个事件执行耗时长，会主动break，等待下一个循环继续调度。
而redis6.0使用多线程io后，事件不太可能会有长耗时了
```

1. 使用场景：
  答：
    1. 优选默认词配合结果页做秒杀活动，获取**网店+用户维度秒杀商品(秒杀商品有限购，所以是用户维度的)，用于展示**，默认词高峰期2W qps，下游无法接受，而优选**千万用户量级**，**网店+渠道上万量级**，内存缓存是无法接受的，所以选用redis缓存
    2. 缓存时长一小时，key加上随机时间避免同时失效。上游加熔断，下游加限流
    3. 考虑通过flink消费下游生产的数据，进一步减小压力，增加实时性。
    4. 缓存雪崩(cache avalanche): 缓存同时失效，设置随机过期时间，userid作为key，一般不会出现。但是**如果有活动，会导致流量短时间剧增，此时会有大量新用户，会导致下游压力剧增**，秒杀标签对用户来说只是增加提示而已，高峰期直接降级处理，当用户多次刷新时，就有概率拿到数据，进入缓存。
    5. 缓存穿透(cache penetration)：缓存和数据库都不存在value大量请求。在redis写一个失效时间短的0，或利用bloom filter
    6. 缓存击穿(cache miss)：热点key过期，设置永不过期。userid为key，不存在击穿
    7. **bloom filter**: 通过一个bit数组加上多个hash函数，来实现过滤，判断各bit全为1可能存在、有bit为0一定不存在。解决**海量数据去重和缓存穿透问题**
2. cache + db的读写模式：
  答：非秒杀等强一致场景下
    * 读：先读cache，不存在则读db，写入cache，返回数据
    * 写：先更新db，再删除cache。之所以**删除而不是更新cache**
      * **利用懒加载的思想，更新的数据不一定会读**
      * **多线程更新需要加锁，否则会导致数据不一致问题。直接删除不会有问题，因为数据重建时一般采用last writer win原则，最差的情况是读到过期数据，但是不会导致数据错误**
      * **补充上一条，如果选择更新缓存，那么多线程更新时，有可能后更新db的线程先完成cache更新，那么就会导致cache里存储的是旧值。而如果每次更新db后都删除缓存，则可以保证cache里读到的是最新值，即使多线程更新，cache数据也会在完成更新后很快和数据库保持一致**
      * 当然，先更新db后删除缓存，仍然有一定风险，因为如果后更新db的线程2删除了缓存，但是另一个线程1在读缓存时，刚好缓存过期失效了，于是先读了旧值。而读完数据后还没来得及写入缓存，线程2已经完成了更新+删除缓存，此时线程1写入旧值，这就导致cache中是旧值，不过这种事情发生的概率非常非常低，需要刚好**cache invalid且read+write cache 耗时大于write db + delete cache**
      * **更新db后不删除cache，而是通过canal订阅binlog，由canal将变更写入mq，去delete cache，可以保证cache一定会在短时间内的到更新**
      * 上述方法看起来已经很完美了，但是实际上还是有问题，因为只考虑了多线程，而没有考虑数据库主从延迟。监听binlog仍然面临问题，假设监听到主库binlog后，要去删除cache，恰巧此时cache失效了，有一个线程读到了从库旧值，而删除cache早于write旧值到cache，此时cache中还是旧值。所以
      * **可以在每行数据的更新中加入版本号(时间戳)，写完db后，获取分布式锁，将最新version写入配置中心，客户端读取的时候携带version，就可以保证短期内一定能读到最新数据。**
        ```
        对于一个后台配置系统来说，这种方案非常实用，因为qps很小，读操作一定由写操作或者业务服务启动诱发，
        就比如开发平台和ab实验平台，平时不会发生读操作，但是一旦更新，瞬时读取qps可能会比较大，所以会在开放平台加一个cache，这样能够保证读操作的尖刺流量不会影响到db。
        ```
3. 过期删除策略：惰性删除(访问时判断，过期则删除)+定期删除(定期执行一次过期删除)
    * 从服务器不关心过期时间，键是否过期主服务器决定

4. redis持久化：
  答：
    1. RDB(database backup file): 二进制文件，fork一个子进程记录某一时刻数据，适合冷备，恢复速度快，对性能影响小。RDB不保存过期键，加载时，主节点忽略过期键。
    2. AOF(append only file): 追加形式，类似binlog。最多丢失一秒的数据，适合做热备，每秒由一个专门的线程异步刷新。AOF对待过期键的策略是，过期时插入一条del语句。恢复时过期键不会被加载。
        * AOF恢复，创建一个伪客户端执行AOF命令
        * AOF重写：根据当前数据状态，启动子进程，重新构建一份AOF文件，期间新命令同时写入AOF缓冲区和AOF重写缓冲区，子进程重写完成后，由父进程将重写缓冲区数据写入新文件，并做替换。然后父进程重新接请求。
    3. **redis使用子进程而不是线程做持久化，因为子进程有完整的父进程数据副本，且不需要加锁**
5. 主从复制：
  答：
    1. 完全重同步sync(rdb写+命令传播): 从服务器第一次连接时
    2. 部分重同步psync(命令传播)：从服务器断连，再次重连后。发送```psync+断连前保存的主服务器id(runid)+复制偏移量offset，主服务器判断，if runid==自己的id && 复制偏移量-offset小于复制缓冲区，则开启psync，否则开启sync```，
5. 主从+哨兵->高可用：
  答：
    1. **哨兵必须用三个实例去保证自己的健壮性的，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用**
    2. **因为领头哨兵选举是广播，且遵循大多数原则，所以实际上2个节点就可以完成。但是要避免节点和服务器部署在同一台物理机上，这样一旦一台物理机宕机，哨兵节点就剩一个了，无法工作，所以需要三个哨兵**