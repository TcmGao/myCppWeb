### 操作系统 [xv6](https://pdos.csail.mit.edu/6.828/2023/xv6/book-riscv-rev3.pdf)
#### 1. xv6操作系统初始化顺序：
* 格式化物理内存，将物理内存分页并用链表串联空闲页
* 创建内核页表：内核的数据段和代码段都是直接映射到物理内存的，页表还有初始化时，satp寄存器的值为0，此时对内存的访问是直接访问物理地址。这个阶段分配很多空闲页，为内核创建一个完整的页表，然后把页表物理地址写入satp，此后内核就页通过页表访问内存。这张页表把所有虚拟地址映射到物理地址，虚拟地址和物理地址相同。这个设计非常巧妙：内核在运行接下来的代码运行不会受到任何影响，因为虚拟pc就是物理pc，只是经过了一次翻译而已。
* 
#### 2. page table
###### (1).页表形式 
* 简单页表：xv6使用39bit中高27bit作为地址，索引pagetable，一条PTE(page table entry)由PPN和一些flags位组成，通过PPN(physcial page number)和低12bit组成物理地址，访问对应地址。低12bit，也就是2<sup>12</sup>即4096bytes = 4k，一页是4k大小。
* 多级页表：页表本身也是占据空间，2<sup>27</sup>作为pte索引，一条pte大小为64bit，那么一个页表大小高达2<sup>30</sup> bytes = 1GB。要用多级页表来减轻负担，高9bit,中9bit，低9bit，分别用来索引下一级页表，这样，通过引入多两级的页表，把单一的页表分割成多个512大小的页表，多了两次索引，但是这样只需要一级页表常驻内存，二级和三级页表都可以被换出。减小了内存占用。因为每个进程都有单独的页表，所以多级页表的重要性更加凸显出来。
* 内核页表：内核虚拟页表是直接映射到物理页的。在xv6中，trampoline页和进程内核栈是例外，trampoline存储着trap到kernel的一些初始代码，每个进程都有一个内核栈，在内核的高地址空间中，超过了正常的可用地址范围，栈之间由一条invalid的PTE分隔
###### (2).物理内存管理
* 物理内存被分成4k大小的页，和逻辑地址页大小一致，这极大简化了地址翻译过程。空闲页可以简单的用一个链表串联，页头部有一个指针指向下一个空闲页。分页管理不再需要考虑内存碎片问题了，物理内存管理变得简单。
###### (3).优化技术
* lazy alloction：当用户程序请求分配空间时，实际并不分配物理空间，只是增加页表条目，标识当前页还未分配，当真正访问时，会发生page fault，此时再分配空间
* copy on write: 子进程完全复制父进程的空间，新增一个引用计数结构，保存物理页被引用次数，当子进程复制父进程空间时，将对应页表PTE标识为只读和copy-on-write的，访问时发生缺页中断，此时分配新空间，更改进程页表，引用计数减一，父子进程都是一样的操作。
* demand pageing: 请求调页，当进程启动时，不分配物理内存，只在真正使用到时才分配内存。
* page replacement: 懒分配时，如果物理地址用完了怎么办，答案是利用LRU和dirty bit逐出一些页，但是逐出页之后如何修改对应进程的PTE为Invalid呢？答案是页帧表，页帧表和页表相反，当然，也不能完全这么说。页帧表其实就是引入copy on write时新增的引用计数结构，在这个结构上为每个物理页(后面统一称呼帧)新增一个指针列表，这些指针指向对应的页表条目，这样当需要逐出一个物理页时，就可以轻轻松松修改所有的页表条目。这个指针列表更新非常简单，和引用计数的更新一样简单，只不过这是一个列表，需要列表操作，仅此而已。

#### 3. system calls
###### (1).系统调用
* there is nothing special for shell，shell就是一个用户级程序，所做的就是打印提示符(prompt)，然后等待用户输入，启动子进程解析并执行输入的命令，然后根据相应命令和参数执行系统调用exec，exec加载对应程序到子进程，完成对应操作。当然，shell内嵌的`cd`命令比较特殊，不需要启动子进程，只需在当前进程切换目录即可。所以shell并没有什么特别，只是定制了一些命令，接收到命令后桶系统调用exec装载对应程序到子进程执行，仅此而已。
###### (2).如何trap进入内核
* 有一组内核操作的寄存器，每次发生system call时，准确来说，是trap时(不止系统调用，设备终端也会trap进入kernel)，内核(也可以说是硬件)会保存当前现场，然后进入内核态(内核态有一个硬件privilege位标识，这也是硬件做的)。
    ```
    #!/usr/bin/perl -w

    # Generate usys.S, the stubs for syscalls.

    print "# generated by usys.pl - do not edit\n";

    print "#include \"kernel/syscall.h\"\n";

    sub entry {
        my $name = shift;
        print ".global $name\n";
        print "${name}:\n";
        print " li a7, SYS_${name}\n";
        print " ecall\n";
        print " ret\n";
    }
	
    entry("fork");
    ```
    这段代码是用来生成system call的用户态代码段的。在这里通过寄存器`a7`传入system call Id，配合其他寄存器传入的参数，然后通过ecall发出中断信号，
    * sepc: 内核会保存当前pc到寄存器sepc。当内核调用sret时，就通过sepc的值覆盖pc，从而返回到用户态，执行用户代码ret，返回到system call发生处，对于用户代码来说，system call就像是一个普通的method call一样。
    * stvec: trap进入kernel时，内核用寄存器stvec的值覆盖pc，stvec就保存了内核代码的入口，
    * scause: 值描述trap进入内核的原因
    * sscratch: 这个值是内核放置的，在trap处理程序的一开始就会派上用场
    * sstatus: 有多位，SIE代表是否开启设备中断，SPP代表中断来自用户还是内核
    * cpu(硬件)所做的具体为：
        * 关中断
        * 保存pc到sepc
        * 设置SPP，代表用户还是内核模式
        * 设置scause
        * 设置supervisor位
        * 拷贝stvec到pc，也就开始执行trap处理程序
    * 操作系统软件要负责切换页表到kernel，还要保存当前其他寄存器和栈信息，系统调用执行完成后需要恢复栈信息。这部分操作可以变成汇编代码，存放在一个单独的trampoline页，每个进程的页表固定地址都绑定到这个页，这样当页表还没有切换到内核时，内核依然可以通过trampoline地址访问到这段代码，完成页表切换和栈保存
###### (3). 中断：
* 用户中断：用户中断处理程序需要保存很多东西，因为进入内核后，一切都将改变，所以每个进程都一个确定的trapframe页地址，用来保存上下文。而
* 内核中断：内核中断和用户中断相似，但是中断处理程序不同，kernel interrupt handler简单，只需要保存一些寄存器到栈上，call kerneltrap()，返回后从栈上恢复寄存器。可以看到这里和user interrupt handler不一样，因为此时已经在内核了，实际上更像一次函数调用，我们只需要保存一些调用者保存寄存器，然后调用函数kerneltrap。
* 时间中断：时间中断是硬件中断，中断处理程序只有少数的几条指令以保证效率，最重要的就是设置一个软件中断位，程序返回后，硬件会检测到这个软件中断位，然后发生软件中断，即内核或者用户中断。