1. 内存结构
  * 分布图
  ![内存结构](resource/jvm_memory.png)
  * 方法区：类的所有信息都存在方法区，堆中分配一个class对象，指向方法区
  * 堆：堆大小可以用-Xmx -Xms控制
  * 对象分配：具体如何申请空间，需要根据垃圾收集算法来确定。一般来说，带有空间压缩的垃圾收集使用**指针碰撞**，即移动指针来分配一块连续空间。而对于标记清除的垃圾收集，则只能采用**空闲列表**的方式分配。**对象分配用CAS确保线程安全**
  * 对象内存布局：对象头、实例数据、对齐填充
    1. 对象头分为三部分：
      * Mark word(32bit系统中): 包括hashCode(25bit)，分代年龄(4bit)、锁标志(2bit)、0(1bit)
      * 类型指针，指向方法区类元数据结构
    2. 实例数据: 父类属性、子类属性
    3. 对齐填充部分，按8字节对齐
  * 栈溢出：hotspot不支持动态栈大小，所以每个线程能分配的栈大小是一定的，用-Xss指定。
    1. 如果栈帧过多，大多数情况是因为循环调用，会导致stackOverFlow
    2. 如果栈帧多大，如果某个方法分配了过多局部变量，导致栈容量不够，会导致stackOverFlow
  * 内存溢出：
    * **如果线程数量过多，因为每个线程能分配的栈容量固定，所以越多线程将会分配越多空间，就会导致发生OutOfMemory**
2. 垃圾收集
  * 判定存活对象
    1. 引用计数：循环引用问题
    2. 可达性判断：基于GC Roots的图搜索，判断可达性。
      * GC Roots: 虚拟机栈的局部变量表、静态变量、常量引用、Native栈中的引用、虚拟机内部引用(如基本类型的class对象和常驻异常对象)、synchronized锁住的对象...
    * 引用类型：引用是一种类型，实际就是指针，和c，c++别无二致，引用存储的是对象地址。但是，Java扩展了引用，加入了强、软、弱、虚四种概念。软引用在下次回收时，就可以回收，弱引用在下次就一定会回收。
    * 第二次机会：第一次被标记为不可达时，会对jvm会调用那些覆盖了finalize()方法且没有调用过finalize的对象的finalize，稍后会才会继续回收，所以对象可以在第一次被回收时通过finalize()逃脱。finalize方法完全可以忘却，因为没有什么用
  * 分代收集理论假设：
    * 大多数对象朝生夕灭
    * 存活越久的对象越不容易被回收
    * 跨代引用很少：将老年代划分成小块，将存在跨代引用的块加入remembered set
  * 标记-清除：标记存活对象，回收未存活对象，会有大量碎片，对象多时效率低、碎片太多而不足以分配一片连续空间时，会再次触发回收
  * **标记复制**：使用两块相同大小空间，标记存活对象，从A移动到B，然后清空A。简单高效，但浪费空间。新生代使用该种算法，因为存活对象少，并且针对**大多数对象朝生夕灭**的假设，将新生代分为eden区和两块小的survivor区，垃圾收集时，将Eden区和A区存活对象复制到B区。而如果10%的B区无法放下所有对象，就需要**老年代做分配担保**
  * 标记整理算法：标记存活对象，移动到另一端，避免内存碎片，但存活对象多时，移动开销很大
  * **老年代回收**：老年代一般可以采用**标记-清除+标记-整理**，因为老年代回收收益不大，根据假设会有大量存活对象，所以**一般采用标记-清除，但是当碎片变多后，使用标记-整理**
  * **Stop The Word**
    * 枚举根节点：必须Stop The Word，即使是ZGC
  * **安全点和安全区域**
    * oopMap用于记录指针，以快速找到可达对象，而不用根据图枚举。而由于oopMap变化多，所以无法对每一条指令都生成一个oopMap，所以需要安全点。
    * 用户线程执行到安全点时，会执行一条插入的汇编指令，读某个地址。如果垃圾收集开始，则收集器将这个地址设置为不可读，用户线程此时会发生中断，如果都发生了中断，就可以开始枚举根节点了。
    * 对于挂起的线程，使用安全区域，执行到安全区域的用户线程会标识自己已进入安全区域
  * remembered set
    * 记忆集用来存储所有非收集区域到收集区域的指针
    * 记忆集中指针指向的块，代表有跨代指针，将该块加入GC Roots
    * 记忆集在新建对象时通过AOP维护
  * 三色标记：即未访问过、访问中(还有引用没有访问完)、已访问过
    * 对象消失：三色标记过程和用户线程并发，如果用户线程切断了访问中对象的未访问对象的引用，并且插入到已访问对象上，就会导致对象消失，即存活对象被标记为可回收，需要通过增量更新或者原始快照打破两个条件。就是扫描完后，再次扫描有新增引用的黑色对象或者那些被切断的引用
    * 上述自然引出CMS收集器：初始标记(STW，枚举出GC Roots直接关联对象)、并发标记(三色标记过程)、重新标记(STW，增量更新或者原始快照以修正)、并发清除
  * Garbase First: G1
    * 分region收集，跟踪region，回收那些价值高的region。
    * minor gc会Stop The World，且不可配置，一般在Eden区用完就会开启。
    * 讨论垃圾收集时，一般讨论包含老年代的收集，因为新生代收集很快
  * ZGC
    * 通过四个bit做染色标记
    * 同样需要初始标记、并发标记、重新标记三个阶段
    * 因为用bit来标记存活状态，并且没有记忆集，所以标记过程很快
    * 将region加入集合，对于集合中的region，每个对象的指针被用于了标记。
    * 现在假设一个regionC要被回收，regionA，regionB中分别有对象指向regionC中的对象，那么regionA和regionB中的这些指针应该要放到一个映射表中，当用户线程通过regionA或者regionB访问regionC中对象时，重定向到映射表。而regionA和regionB中指针的mapped字段被标记为1，当所有region的这些指针都被加入到映射表之后，regionC就可以直接清空了。
3. 解析引用
  * 类文件加载后，会加载常量池到运行时常量池。同时，会使用常量池缓存保存每一个符号引用对应的直接引用。
  * 可以理解为新增了两个map，都以方法的符号引用在常量池中的偏移量作为key，一个保存解析状态，另一个保存直接引用。
  * 同理，对于属性的访问也是如此，jvm会将解析出来的属性偏移量保存在常量池缓存中
  * **常量池缓存**：类似map的结构，key是符号引用在常量池的偏移，value是方法指针或者属性的地址偏移量
* 4. 类加载
  * 加载
  * 链接：验证、准备(赋默认值)、解析(解析符号引用)
  * 初始化：执行类变量的初始化
  * **类型转换**：类型的判断逻辑非常简单，就是**沿着class对象superClass的层级关系逐级向上比较**，不用显示考虑类加载器，因为**class的层级关系是类加载时构建的！！！**。所以，对于父加载器加载父类，子加载器加载子类的情况，可以执行类型转换，因为通过子类的class.superClass可以到父类。
  * 而如果是父加载器加载子类，子加载器加载父类，此时类型转换不可控。但是此时行为实际上是不可控的。现在假设有一个trick的加载器，只加载父类A。存在两种情况
    * 先调用子加载器加载子类，此时会先加载父类(由sub加载)，然后加载子类(由parent加载)，class层级关系可以建立
    * 先调用子加载器加载父类，再加载子类，和情况一是一样的。
    * 而父加载器如果要加载父类，此时父加载器加载的子类和父类没有父子关系。
    * 先调用父加载器加载子类，此时会先加载父类(由parent加载)，然后加载子类(由parent加载)，子加载器再去加载父类(注意，一定是主动调用loadClass，如果是调用A.class，那么会返回父加载器加载的类，因为JVM是可以在父加载器缓存查找到一个父类class的，此时会直接返回，而不会触发loadClass)。此时类型转换是不可用的。因为class层级关系不存在
    * **类查找**：当在当前类加载器下查找类A时，首先调用**findLoadedClass，如果找不到，再调用parent.findLoadedClas**，JVM可能还会为加载器缓存查找结果，下次就不再需要通过parent了，而是可以直接在自己的缓存里找到。这个缓存是弱引用，所以需要在类加载器里维护一个强引用的vector，确保类不会在类加载器被回收前回收
      
* 并发编程
  * 原子性：一般用CAS操作保证原子性
  * 顺序性
  * 可见性：**内存屏障**提供可见性保证，最朴素的理解是，当我们**插入一个读屏障后，使得缓存失效，一定能读到内存数据**。当我们**插入一个写屏障，那么这个屏障之前的所有写都会同步到内存**。
  * **内存屏障**：内存屏障提供可见性和顺序性保证。